<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Video Satellite 3.0 (Elastic Time)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 0; display: flex; flex-direction: column; height: 100vh; background: #111; color: #eee; }
        #main-container { display: flex; flex: 1; overflow: hidden; }
        #video-section { flex: 2; background: #000; position: relative; display: flex; align-items: center; justify-content: center; border-right: 1px solid #333; }
        #map-section { flex: 1; min-width: 300px; position: relative; }
        video { width: 100%; height: 100%; max-height: 100vh; object-fit: contain; }
        
        #controls { padding: 10px; background: #222; border-bottom: 1px solid #444; display: flex; gap: 15px; align-items: center; z-index: 1000; flex-wrap: wrap; }
        
        .btn-upload { background: #444; color: #fff; border: 1px solid #666; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; }
        .btn-upload:hover { background: #666; }
        #fileInput { display: none; }

        .hud { font-family: 'Consolas', monospace; display: flex; gap: 15px; margin-left: auto; }
        .stat-item { display: flex; flex-direction: column; align-items: flex-end; }
        .stat-val { font-size: 1.1em; font-weight: bold; color: #4facfe; }
        .stat-lbl { font-size: 0.7em; color: #888; }
        
        .toggle-label { font-size: 0.8em; color: #ccc; cursor: pointer; display: flex; align-items: center; gap: 5px; border: 1px solid #444; padding: 4px 8px; border-radius: 4px; background: #333; }
        .toggle-label:hover { background: #444; }

        #map { width: 100%; height: 100%; background: #222; }
        .sync-marker { width: 16px; height: 16px; background: #ff0055; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 10px #ff0055; }
    </style>
</head>
<body>

    <div id="controls">
        <button class="btn-upload" onclick="document.getElementById('fileInput').click()">ðŸ“‚ Load Files</button>
        <input type="file" id="fileInput" multiple accept=".json, .webm, .mp4, .mov">

        <label class="toggle-label" title="Stretch the GPS path to fit the video duration">
            <input type="checkbox" id="chkElastic"> Elastic Mode
        </label>

        <div class="hud">
            <div class="stat-item"><span class="stat-val" id="dispTime">00:00</span><span class="stat-lbl">TIME</span></div>
            <div class="stat-item"><span class="stat-val" id="dispVel">0.0</span><span class="stat-lbl">KM/H</span></div>
            <div class="stat-item"><span class="stat-val" id="dispAcc" style="color:#ff0055;">0.0</span><span class="stat-lbl">ACC</span></div>
        </div>
    </div>

    <div id="main-container">
        <div id="video-section"><video id="main-player" controls playsinline></video></div>
        <div id="map-section"><div id="map"></div></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const map = L.map('map', { zoomControl: false }).setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
        const pathLayer = L.polyline([], {color: '#4facfe', weight: 4, opacity: 0.8}).addTo(map);
        let syncMarker = null;
        let trackPoints = [];
        const syncChannel = new BroadcastChannel('song_sync_channel');

        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const files = e.target.files;
            let jsonFile = null, videoFile = null;
            for (let f of files) {
                if (f.name.toLowerCase().endsWith('.json')) jsonFile = f;
                if (f.name.match(/\.(webm|mp4|mov)$/i)) videoFile = f;
            }
            if (!jsonFile || !videoFile) { alert("Select BOTH .json and .webm/.mp4"); return; }
            
            document.getElementById('main-player').src = URL.createObjectURL(videoFile);
            const text = await jsonFile.text();
            try {
                const data = JSON.parse(text);
                trackPoints = data.track_points || data.points;
                processTrack();
            } catch(err) { alert("JSON Error"); }
        });

        function processTrack() {
            const latLngs = trackPoints.map(p => [p.lat||p.latitude, p.lng||p.longitude]);
            pathLayer.setLatLngs(latLngs);
            if (latLngs.length > 0) {
                map.fitBounds(pathLayer.getBounds(), {padding:[20,20]});
                if (syncMarker) map.removeLayer(syncMarker);
                syncMarker = L.marker(latLngs[0], {
                    icon: L.divIcon({ className: 'sync-marker', iconSize: [20,20], iconAnchor: [10,10] }),
                    zIndexOffset:1000
                }).addTo(map);
            }
        }

        const player = document.getElementById('main-player');
        
        player.ontimeupdate = () => {
            const t = player.currentTime;
            const duration = player.duration || 1; // Prevent div/0
            
            // 1. BROADCAST
            syncChannel.postMessage({ type: 'sync_time', time: t });

            // 2. UPDATE MAP
            if (trackPoints.length < 2) return;
            
            const isElastic = document.getElementById('chkElastic').checked;
            let targetGPS = null;

            if (isElastic) {
                // Mode A: ELASTIC (Stretch Path to Video)
                // Percent of video played
                const pct = t / duration; 
                
                // Map to Total GPS Duration
                const startT = trackPoints[0].time;
                const endT = trackPoints[trackPoints.length-1].time;
                const totalT = endT - startT;
                
                // Target GPS Time
                const seekT = startT + (totalT * pct);
                targetGPS = getPointAtTime(seekT);
                
            } else {
                // Mode B: REAL TIME (Absolute Sync)
                // Assumes video starts at t=0 of the run. 
                // (Ideally, we would use the "REC" marker timestamp, but that requires parsing separate marker data)
                targetGPS = getPointAtTime(t);
            }

            if (targetGPS) {
                if(syncMarker) syncMarker.setLatLng([targetGPS.lat, targetGPS.lng]);
                
                // Auto-pan
                if(!map.getBounds().contains([targetGPS.lat, targetGPS.lng])) map.panTo([targetGPS.lat, targetGPS.lng]);

                // Update HUD
                const v = (targetGPS.vel||0) * 3.6; // km/h
                const a = (targetGPS.acc||0) * 3.6; // km/h/s (roughly)
                document.getElementById('dispVel').innerText = v.toFixed(1);
                document.getElementById('dispAcc').innerText = a.toFixed(1);
            }
            
            const m = Math.floor(t/60);
            const s = Math.floor(t%60);
            document.getElementById('dispTime').innerText = `${m}:${s.toString().padStart(2,'0')}`;
        };

        function getPointAtTime(t) {
            // Find segment
            let idx = -1;
            for(let i=0; i < trackPoints.length-1; i++) {
                if (t >= trackPoints[i].time && t <= trackPoints[i+1].time) {
                    idx = i; break;
                }
            }
            
            if (idx === -1) {
                // Handle edges
                if (t < trackPoints[0].time) return trackPoints[0];
                if (t > trackPoints[trackPoints.length-1].time) return trackPoints[trackPoints.length-1];
                return null;
            }

            const p1 = trackPoints[idx];
            const p2 = trackPoints[idx+1];
            const factor = (t - p1.time) / (p2.time - p1.time);
            
            return {
                lat: (p1.lat||p1.latitude) + ((p2.lat||p2.latitude) - (p1.lat||p1.latitude)) * factor,
                lng: (p1.lng||p1.longitude) + ((p2.lng||p2.longitude) - (p1.lng||p1.longitude)) * factor,
                vel: (p1.vel||0) + ((p2.vel||0) - (p1.vel||0)) * factor,
                acc: (p1.acc||0) + ((p2.acc||0) - (p1.acc||0)) * factor
            };
        }
    </script>
</body>
</html>