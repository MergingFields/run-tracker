<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Run Viewer 5 (Scientific)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; margin: 0; display: flex; flex-direction: column; height: 100vh; background: #111; color: #eee; }
        
        /* HEADER */
        #controls { padding: 10px 15px; background: #222; border-bottom: 1px solid #444; display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px; }
        .control-group { display: flex; gap: 15px; align-items: center; }
        .toggle-label { font-size: 0.9em; color: #ccc; cursor: pointer; user-select: none; display: flex; align-items: center; gap: 5px; }
        
        /* LAYOUT */
        #map-container { flex-grow: 1; position: relative; min-height: 0; }
        #map { height: 100%; width: 100%; }
        
        /* CHART AREA */
        #charts-container { height: 40vh; background: #1a1a1a; padding: 0; border-top: 1px solid #444; position: relative; overflow: hidden; display: flex; flex-direction: column; }
        #chart-svg { width: 100%; height: 100%; display: block; cursor: crosshair; }
        
        /* SVG ELEMENTS */
        text { font-family: monospace; font-size: 10px; fill: #888; }
        .axis-line { stroke: #444; stroke-width: 1; }
        .grid-line { stroke: #333; stroke-width: 1; stroke-dasharray: 2,2; }
        
        /* Data Lines */
        .line-vel { fill: none; stroke: #4facfe; stroke-width: 2; vector-effect: non-scaling-stroke; }
        .line-acc { fill: none; stroke: #ff0055; stroke-width: 1.5; vector-effect: non-scaling-stroke; opacity: 0.8; }
        
        /* Cursor & Dots */
        .cursor-line { stroke: white; stroke-width: 1; vector-effect: non-scaling-stroke; pointer-events: none; }
        .photo-dot { fill: #ffd700; stroke: #000; stroke-width: 1; cursor: pointer; transition: r 0.2s; }
        .photo-dot:hover { r: 8; fill: white; }

        /* HIDE STATES */
        .hidden { display: none !important; }
        
        /* MAP MARKERS */
        .photo-marker { transition: transform 0.2s; box-sizing: border-box; }
        .photo-marker:hover { transform: scale(1.2); z-index: 1000 !important; }
        .active-photo { border-color: #ffd700 !important; box-shadow: 0 0 15px #ffd700 !important; transform: scale(1.4); z-index: 9999 !important; }

        /* SLIDER */
        #scrubber-container { width: 100%; padding: 5px 10px; box-sizing: border-box; background: #222; }
        input[type=range] { width: 100%; cursor: pointer; }
        
        /* STATS DISPLAY */
        .stats-panel { font-family: monospace; font-size: 0.9em; text-align: right; }
        .val-vel { color: #4facfe; font-weight: bold; }
        .val-acc { color: #ff0055; font-weight: bold; }
    </style>
</head>
<body>

    <div id="controls">
        <div class="control-group">
            <h2 style="margin:0; font-size: 1.1em;">üèÉ View 5</h2>
            <input type="file" id="fileInput" accept=".json">
        </div>
        
        <div class="control-group">
            <label class="toggle-label"><input type="checkbox" id="toggleMap" checked> Map</label>
            <label class="toggle-label"><input type="checkbox" id="toggleChart" checked> Chart</label>
            <label class="toggle-label" style="color:#ff0055"><input type="checkbox" id="toggleAcc"> Accel</label>
        </div>

        <div class="stats-panel">
            <div>Time: <span id="syncTime" style="color:white">00:00</span></div>
            <div>Vel: <span id="syncVel" class="val-vel">0.0</span> m/s</div>
            <div id="accStatBox" style="display:none">Acc: <span id="syncAcc" class="val-acc">0.0</span> m/s¬≤</div>
        </div>
    </div>

    <div id="map-container">
        <div id="map"></div>
    </div>

    <div id="charts-container">
        <svg id="chart-svg" preserveAspectRatio="none">
            <g id="grid-layer"></g>
            <path id="path-vel" class="line-vel" d="" />
            <path id="path-acc" class="line-acc" d="" style="display:none;" />
            <line id="scrubber-line" class="cursor-line" x1="0" y1="0" x2="0" y2="100%" />
            <g id="axis-layer"></g>
            <g id="photo-dots-layer"></g>
        </svg>
    </div>
    
    <div id="scrubber-container">
        <input type="range" id="timeSlider" min="0" max="100" value="0" step="0.1">
    </div>

    <script>
        // --- CONFIG ---
        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
            attribution: '¬© OSM', className: 'map-tiles' 
        }).addTo(map);
        document.querySelector('.map-tiles').style.filter = "invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%)";

        const pathLayer = L.polyline([], {color: '#4facfe', weight: 4}).addTo(map);
        const runnerMarker = L.circleMarker([0,0], { radius: 8, color: 'white', fillColor: '#ff0055', fillOpacity: 1 }).addTo(map);
        
        let runData = null;
        let photoMarkers = []; 
        let maxRunTime = 0;
        
        // Data Ranges
        let maxVel = 0;
        let minAcc = 0;
        let maxAcc = 0;

        // --- 1. UI LISTENERS ---
        document.getElementById('toggleMap').addEventListener('change', (e) => {
            const el = document.getElementById('map-container');
            if(e.target.checked) el.classList.remove('hidden'); else el.classList.add('hidden');
            map.invalidateSize();
        });
        document.getElementById('toggleChart').addEventListener('change', (e) => {
            const el = document.getElementById('charts-container');
            if(e.target.checked) el.classList.remove('hidden'); else el.classList.add('hidden');
        });
        document.getElementById('toggleAcc').addEventListener('change', (e) => {
            const el = document.getElementById('path-acc');
            const stat = document.getElementById('accStatBox');
            if(e.target.checked) { el.style.display = 'block'; stat.style.display = 'block'; } 
            else { el.style.display = 'none'; stat.style.display = 'none'; }
        });

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    runData = JSON.parse(event.target.result);
                    initVisualizer(runData);
                } catch (err) { alert("Error parsing JSON."); }
            };
            reader.readAsText(file);
        });

        // --- 2. INIT ---
        function initVisualizer(data) {
            // A. MAP
            const latlngs = data.track_points.map(p => [p.lat, p.lng]);
            pathLayer.setLatLngs(latlngs);
            if (latlngs.length > 0) {
                map.fitBounds(pathLayer.getBounds());
                runnerMarker.setLatLng(latlngs[0]);
            }
            
            // B. RANGES
            maxRunTime = data.track_points[data.track_points.length - 1].time;
            
            // Calc Max/Min for Scaling
            maxVel = 0;
            minAcc = 0; 
            maxAcc = 0;
            
            data.track_points.forEach(p => { 
                if(p.vel > maxVel) maxVel = p.vel;
                const a = p.acc || 0;
                if(a > maxAcc) maxAcc = a;
                if(a < minAcc) minAcc = a;
            });
            
            // Safety defaults if data is flat
            if(maxVel === 0) maxVel = 1;
            if(maxAcc === 0 && minAcc === 0) { maxAcc = 1; minAcc = -1; }
            // Add padding to Acc
            const accRange = maxAcc - minAcc;
            maxAcc += accRange * 0.1;
            minAcc -= accRange * 0.1;

            // Setup Slider
            const slider = document.getElementById('timeSlider');
            slider.max = maxRunTime;
            slider.value = 0;

            // C. DRAW CHART
            drawSvgChart(data);

            // D. PHOTOS
            photoMarkers = []; 
            if (data.photos) {
                data.photos.forEach(photo => {
                    let imgSrc = photo.src_chunks ? photo.src_chunks.join('') : photo.src;
                    
                    // Match Time
                    let closestTime = 0;
                    let minDist = Infinity;
                    data.track_points.forEach(p => {
                        const d = Math.sqrt(Math.pow(p.lat - photo.lat, 2) + Math.pow(p.lng - photo.lng, 2));
                        if(d < minDist) { minDist = d; closestTime = p.time; }
                    });

                    // Map Marker
                    const icon = L.divIcon({
                        html: `<div style="background-image: url('${imgSrc}'); width: 30px; height: 30px; background-size: cover; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 5px black;"></div>`,
                        className: 'photo-marker',
                        iconSize: [34, 34], iconAnchor: [17, 34]
                    });
                    const marker = L.marker([photo.lat, photo.lng], {icon: icon}).addTo(map);
                    const headingStr = photo.heading ? `<br>Heading: ${photo.heading}¬∞` : "";
                    marker.bindPopup(`<img src="${imgSrc}" style="width:200px; border-radius: 8px;">${headingStr}`);
                    
                    photoMarkers.push({ marker: marker, runTime: closestTime, isOpen: false });
                });
            }
        }

        // --- 3. ADVANCED SVG CHART ---
        function drawSvgChart(data) {
            const svg = document.getElementById('chart-svg');
            const pathVel = document.getElementById('path-vel');
            const pathAcc = document.getElementById('path-acc');
            const dotsLayer = document.getElementById('photo-dots-layer');
            const axisLayer = document.getElementById('axis-layer');
            const gridLayer = document.getElementById('grid-layer');

            // We use a coordinate system where:
            // X = Time (0 to maxRunTime)
            // Y = 0 to 100 (Percentage based)
            svg.setAttribute('viewBox', `0 0 ${maxRunTime} 100`);

            // Helper to map values to Y (0-100)
            // Note: SVG Y=0 is Top, Y=100 is Bottom.
            const getVelY = (v) => 100 - ((v / maxVel) * 100);
            const getAccY = (a) => 100 - (((a - minAcc) / (maxAcc - minAcc)) * 100);

            // 1. Build Paths
            let dVel = "";
            let dAcc = "";
            
            data.track_points.forEach((p, i) => {
                const x = p.time;
                const yV = getVelY(p.vel);
                const yA = getAccY(p.acc || 0);

                if (i === 0) {
                    dVel += `M ${x} ${yV}`;
                    dAcc += `M ${x} ${yA}`;
                } else {
                    dVel += ` L ${x} ${yV}`;
                    dAcc += ` L ${x} ${yA}`;
                }
            });

            pathVel.setAttribute('d', dVel);
            pathAcc.setAttribute('d', dAcc);

            // 2. Draw Axes & Grid
            axisLayer.innerHTML = '';
            gridLayer.innerHTML = '';

            // X-Axis (Time) - 10 ticks
            const xStep = maxRunTime / 10;
            for(let t=0; t<=maxRunTime; t+=xStep) {
                // Grid Line
                const grid = document.createElementNS("http://www.w3.org/2000/svg", "line");
                grid.setAttribute("x1", t); grid.setAttribute("y1", 0);
                grid.setAttribute("x2", t); grid.setAttribute("y2", 100);
                grid.setAttribute("class", "grid-line");
                gridLayer.appendChild(grid);

                // Label
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", t + (maxRunTime*0.01)); 
                text.setAttribute("y", 98);
                const m = Math.floor(t/60); const s = Math.floor(t%60);
                text.textContent = `${m}:${s.toString().padStart(2,'0')}`;
                axisLayer.appendChild(text);
            }

            // Left Y-Axis (Velocity - Blue) - 5 ticks
            for(let i=0; i<=5; i++) {
                const val = (maxVel / 5) * i;
                const y = getVelY(val);
                
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", 0); 
                text.setAttribute("y", y - 2);
                text.setAttribute("fill", "#4facfe");
                text.textContent = val.toFixed(1) + " m/s";
                axisLayer.appendChild(text);
            }

            // Right Y-Axis (Accel - Red) - 5 ticks
            const accStep = (maxAcc - minAcc) / 5;
            for(let i=0; i<=5; i++) {
                const val = minAcc + (accStep * i);
                const y = getAccY(val);
                
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", maxRunTime); 
                text.setAttribute("y", y - 2);
                text.setAttribute("fill", "#ff0055");
                text.setAttribute("text-anchor", "end"); // Align right
                text.textContent = val.toFixed(1) + " m/s¬≤";
                axisLayer.appendChild(text);
            }

            // 3. Photo Dots
            dotsLayer.innerHTML = ''; 
            if (data.photos) {
                data.photos.forEach(photo => {
                    // Re-find time/vel
                    let closestP = data.track_points[0];
                    let minDist = Infinity;
                    data.track_points.forEach(p => {
                        const d = Math.sqrt(Math.pow(p.lat - photo.lat, 2) + Math.pow(p.lng - photo.lng, 2));
                        if(d < minDist) { minDist = d; closestP = p; }
                    });

                    const cx = closestP.time;
                    const cy = getVelY(closestP.vel);

                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", cx);
                    circle.setAttribute("cy", cy);
                    circle.setAttribute("r", 1.5); // Slightly larger visual size (relative to viewBox)
                    circle.setAttribute("class", "photo-dot");
                    
                    circle.onclick = () => {
                        const slider = document.getElementById('timeSlider');
                        slider.value = closestP.time;
                        updateFrame(closestP.time);
                        // Find map marker
                        const pm = photoMarkers.find(m => Math.abs(m.runTime - closestP.time) < 1);
                        if(pm) pm.marker.openPopup();
                    };
                    dotsLayer.appendChild(circle);
                });
            }
        }


        // --- 4. ANIMATION LOOP ---
        document.getElementById('timeSlider').addEventListener('input', function(e) {
            updateFrame(parseFloat(this.value));
        });

        window.addEventListener('message', function(event) {
            if (event.data.type !== 'run_viewer_sync' || !runData) return;
            const { currentTime, totalDuration } = event.data;
            if (totalDuration <= 0) return;
            const progress = currentTime / totalDuration;
            const currentRunTime = progress * maxRunTime;
            document.getElementById('timeSlider').value = currentRunTime;
            updateFrame(currentRunTime);
        });

        function updateFrame(time) {
            if (!runData) return;
            
            // A. Stats
            const m = Math.floor(time / 60);
            const s = Math.floor(time % 60);
            document.getElementById('syncTime').innerText = `${m}:${s.toString().padStart(2, '0')}`;

            // B. Interpolation
            const points = runData.track_points;
            let idx = -1;
            for(let i=0; i < points.length - 1; i++) {
                if (time >= points[i].time && time < points[i+1].time) { idx = i; break; }
            }

            if (idx !== -1) {
                const p1 = points[idx];
                const p2 = points[idx+1];
                const fraction = (time - p1.time) / (p2.time - p1.time);
                
                const lat = p1.lat + (p2.lat - p1.lat) * fraction;
                const lng = p1.lng + (p2.lng - p1.lng) * fraction;
                const vel = p1.vel + (p2.vel - p1.vel) * fraction;
                const acc = (p1.acc || 0) + ((p2.acc || 0) - (p1.acc || 0)) * fraction;

                runnerMarker.setLatLng([lat, lng]);
                document.getElementById('syncVel').innerText = vel.toFixed(1);
                document.getElementById('syncAcc').innerText = acc.toFixed(2);
            } else {
                if (time >= points[points.length-1].time) {
                    const p = points[points.length-1];
                    runnerMarker.setLatLng([p.lat, p.lng]);
                }
            }

            // C. SVG Cursor
            const scrubber = document.getElementById('scrubber-line');
            scrubber.setAttribute('x1', time);
            scrubber.setAttribute('x2', time);

            // D. Photos
            const PHOTO_WINDOW = 15; 
            photoMarkers.forEach(pm => {
                const dist = Math.abs(pm.runTime - time);
                const markerIcon = pm.marker.getElement();
                if (dist < PHOTO_WINDOW) {
                    if (!pm.isOpen) {
                        pm.marker.openPopup();
                        if(markerIcon) markerIcon.classList.add('active-photo');
                        pm.isOpen = true;
                    }
                } else {
                    if (pm.isOpen) {
                        pm.marker.closePopup();
                        if(markerIcon) markerIcon.classList.remove('active-photo');
                        pm.isOpen = false;
                    }
                }
            });
        }
    </script>
</body>
</html>