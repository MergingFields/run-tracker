<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Viewer - Game Loop Mode (Analysis)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: 'Courier New', monospace; overflow: hidden; }
        
        /* Dashboard Grid */
        #dashboard { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 60vh 40vh; height: 100vh; width: 100vw; }
        
        #map-panel { grid-column: 1; grid-row: 1; position: relative; border-right: 2px solid #333; }
        #video-panel { grid-column: 2; grid-row: 1; position: relative; background: #111; display: flex; justify-content: center; align-items: center; }
        #graph-panel { grid-column: 1 / span 2; grid-row: 2; background: #050505; border-top: 2px solid #333; padding: 10px; position: relative; }

        /* Video & Canvas Overlay */
        video { width: 100%; max-height: 100%; }
        canvas { position: absolute; top: 0; left: 0; pointer-events: none; }

        /* Floating Controls */
        #controls { position: absolute; top: 10px; left: 10px; z-index: 999; background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #444; }
        input[type="file"] { display: block; margin-bottom: 5px; color: white; }
    </style>
</head>
<body>

    <div id="controls">
        <strong>GAME LOOP MODE</strong><br>
        <small>Interpolated & Hi-Res</small><br><br>
        <input type="file" id="jsonInput" accept=".json">
        <input type="file" id="videoInput" accept="video/*">
        <button onclick="document.getElementById('mainVideo').play()">PLAY</button>
        <button onclick="document.getElementById('mainVideo').pause()">PAUSE</button>
        <div id="fps-counter" style="color: #fff; margin-top:5px;">FPS: 0</div>
    </div>

    <div id="dashboard">
        <div id="map-panel"></div>
        
        <div id="video-panel">
            <video id="mainVideo" playsinline></video>
            <canvas id="hudCanvas"></canvas>
        </div>
        
        <div id="graph-panel">
            <canvas id="graphCanvas"></canvas>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // --- SETUP ---
        const map = L.map('map-panel').setView([55.75, 12.56], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'OSM' }).addTo(map);
        
        const layers = {
            marker: L.circleMarker([0,0], { color: '#0f0', radius: 8 }).addTo(map),
            path: L.polyline([], { color: '#054400', weight: 2 }).addTo(map)
        };

        const vid = document.getElementById('mainVideo');
        const hudCanvas = document.getElementById('hudCanvas');
        const hudCtx = hudCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        let trackData = [];
        let isReady = false;

        // --- RESIZE HANDLER ---
        function resize() {
            hudCanvas.width = vid.clientWidth || 600;
            hudCanvas.height = vid.clientHeight || 400;
            graphCanvas.width = document.getElementById('graph-panel').clientWidth;
            graphCanvas.height = document.getElementById('graph-panel').clientHeight;
        }
        window.addEventListener('resize', resize);
        // Call once to init
        setTimeout(resize, 1000);

        // --- LOAD DATA ---
        document.getElementById('jsonInput').addEventListener('change', (e) => {
            const reader = new FileReader();
            reader.onload = (evt) => {
                const json = JSON.parse(evt.target.result);
                trackData = json.track_points || [];
                
                // Draw path immediately
                const latlngs = trackData.map(p => [p.lat, p.lng]);
                layers.path.setLatLngs(latlngs);
                map.fitBounds(layers.path.getBounds());
                
                isReady = true;
                drawStaticGraph(); // Draw the full timeline at bottom
            };
            reader.readAsText(e.target.files[0]);
        });

        document.getElementById('videoInput').addEventListener('change', (e) => {
            vid.src = URL.createObjectURL(e.target.files[0]);
            resize();
        });

        // --- THE GAME LOOP (requestAnimationFrame) ---
        function loop() {
            if(isReady && !vid.paused) {
                const t = vid.currentTime;
                
                // 1. Find Data & Interpolate
                const state = getInterpolatedState(t);
                
                if(state) {
                    // Update Map (Smoothly)
                    layers.marker.setLatLng([state.lat, state.lng]);
                    
                    // Draw HUD (Overlay on Video)
                    drawHUD(state);
                    
                    // Draw Live Indicator on Graph
                    drawGraphCursor(t);
                }
            }
            
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);


        // --- LOGIC: INTERPOLATION ---
        function getInterpolatedState(time) {
            // Find the two points bounding the current time
            // Optimize: For large files, use Binary Search. Here simple loop is ok for demo.
            for(let i=0; i<trackData.length - 1; i++) {
                const p1 = trackData[i];
                const p2 = trackData[i+1];
                
                if(time >= p1.time && time < p2.time) {
                    // We are between p1 and p2. Calculate percentage (0.0 to 1.0)
                    const duration = p2.time - p1.time;
                    const elapsed = time - p1.time;
                    const pct = elapsed / duration;
                    
                    // Linear Interpolation (Lerp)
                    return {
                        lat: p1.lat + (p2.lat - p1.lat) * pct,
                        lng: p1.lng + (p2.lng - p1.lng) * pct,
                        vel: p1.vel + (p2.vel - p1.vel) * pct,
                        acc: p1.acc + (p2.acc - p1.acc) * pct
                    };
                }
            }
            return trackData[0]; // Default
        }

        // --- DRAWING ---
        function drawHUD(state) {
            hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
            
            // Draw Velocity Bar
            const barHeight = Math.min(state.vel * 10, 100); // Scale factor
            hudCtx.fillStyle = "rgba(0, 255, 0, 0.5)";
            hudCtx.fillRect(20, hudCanvas.height - 20 - barHeight, 30, barHeight);
            
            // Text
            hudCtx.fillStyle = "#fff";
            hudCtx.font = "16px monospace";
            hudCtx.fillText(`VEL: ${state.vel.toFixed(1)} m/s`, 20, hudCanvas.height - 130);
            hudCtx.fillText(`ACC: ${state.acc.toFixed(2)}`, 20, hudCanvas.height - 150);
        }

        function drawStaticGraph() {
            // Draw the full velocity profile
            const w = graphCanvas.width;
            const h = graphCanvas.height;
            const ctx = graphCtx;
            
            ctx.clearRect(0,0,w,h);
            ctx.strokeStyle = "#004400";
            ctx.beginPath();
            
            const totalTime = trackData[trackData.length-1].time;
            
            for(let i=0; i<trackData.length; i++) {
                const pt = trackData[i];
                const x = (pt.time / totalTime) * w;
                const y = h - (pt.vel * 5); // Scale vel to height
                if(i===0) ctx.moveTo(x,y);
                else ctx.lineTo(x,y);
            }
            ctx.stroke();
        }

        function drawGraphCursor(time) {
            // Re-draw graph background (naive) or just draw cursor over it
            // For efficiency, usually we use 2 layers. Here we just redraw cursor line.
            // (Simple hack: clear rect just for cursor? No, simple redraw static first)
            drawStaticGraph();
            
            const w = graphCanvas.width;
            const totalTime = trackData[trackData.length-1].time;
            const x = (time / totalTime) * w;
            
            graphCtx.strokeStyle = "#fff";
            graphCtx.beginPath();
            graphCtx.moveTo(x, 0);
            graphCtx.lineTo(x, graphCanvas.height);
            graphCtx.stroke();
        }

    </script>
</body>
</html>